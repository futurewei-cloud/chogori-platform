#pragma once
#include <k2/common/Common.h>
#include <k2/transport/PayloadSerialization.h>
#include <k2/transport/Status.h>

#include "Collection.h"
#include "TSO.h"
namespace k2 {
namespace dto {

// common transaction priorities
enum TxnPriority : uint8_t {
    Highest = 0,
    High = 64,
    Medium = 128,
    Low = 192,
    Lowest = 255
};

// Minimum Transaction Record - enough to identify a transaction.
struct K23SI_MTR {
    uint64_t txnid = 0; // the transaction ID: random generated by client
    Timestamp timestamp; // the TSO timestamp of the transaction
    TxnPriority priority = TxnPriority::Medium;  // transaction priority: user-defined: used to pick abort victims by K2 (0 is highest)
    bool operator==(const K23SI_MTR& o) const;
    bool operator!=(const K23SI_MTR& o) const;
    K2_PAYLOAD_FIELDS(txnid, timestamp, priority);
};
// zero-value for MTRs
extern const K23SI_MTR K23SI_MTR_ZERO;

// TRH ID identifies the Transaction Record Holder - the partition which holds
// the transaction record for a given transaction.
struct K23SI_TRH_ID {
    Key key; // the key for the transaction record
    K2_PAYLOAD_FIELDS(key);
};

// The main READ DTO.
struct K23SIReadRequest {
    Partition::PVID pvid; // the partition version ID. Should be coming from an up-to-date partition map
    String collectionName; // the name of the collection
    K23SI_MTR mtr; // the MTR for the issuing transaction
    Key key; // the key to read
    K2_PAYLOAD_FIELDS(pvid, collectionName, mtr, key);
};

// The response for READs
template<typename ValueType>
struct K23SIReadResponse {
    Key key; // the key of the record
    SerializeAsPayload<ValueType> value; // the value we found
    // In cases where we had to abort the read, this will be set to the priority of the winning transaction
    TxnPriority abortPriority = TxnPriority::Lowest;
    K2_PAYLOAD_FIELDS(key, value, abortPriority);
};

// status codes for reads
struct K23SIReadStatus {
    static Status KeyNotFound() { return k2::Status::S404_Not_Found();}
    static Status RefreshCollection() { return k2::Status::S410_Gone();}
    static Status AbortConflict() { return k2::Status::S409_Conflict();}
    static Status AbortRequestTooOld() { return k2::Status::S403_Forbidden();}
    static Status OK() { return k2::Status::S200_OK();}
};

template <typename ValueType>
struct K23SIWriteRequest {
    Partition::PVID partitionVID;
    String collectionName;
    K23SI_MTR mtr;
    K23SI_TRH_ID trh;
    Key key;
    SerializeAsPayload<ValueType> value;
    K2_PAYLOAD_FIELDS(partitionVID, collectionName, mtr, trh, key, value);
};

struct K23SIWriteResponse {
    TxnPriority abortPriority = TxnPriority::Lowest;
    K2_PAYLOAD_COPYABLE;
};

struct K23SITxnPushRequest {
    K2_PAYLOAD_COPYABLE;
};

struct K23SITxnPushResponse {
    K2_PAYLOAD_COPYABLE;
};

struct K23SITxnEndRequest {
    K2_PAYLOAD_COPYABLE;
};

struct K23SITxnEndResponse {
    K2_PAYLOAD_COPYABLE;
};

struct K23SITxnFinalizeRequest {
    K2_PAYLOAD_COPYABLE;
};

struct K23SITxnFinalizeResponse {
    K2_PAYLOAD_COPYABLE;
};

} // ns dto
} // ns k2
