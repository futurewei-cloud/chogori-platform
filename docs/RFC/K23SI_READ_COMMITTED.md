### Overview

K2-3SI natively only support serializable snapshot isolation transactions. An enhancement of it with ReadCommitted isolation transaction will provide more options and solve some weakness/problem (list below) when user scenario is ok with this reduced isolation level.

### Problems ReadCommitted transaction could solve or mitigate

* K2-3SI read transaction is at snapshot isolation level, which by default run with current timestamp, may conflict with write transactions working on the same data. This will reduce system throughput when transaction concurrency on the same data is high, confliction ratio is high. 
* K2-3SI snapshot isolation level read will take hold of the all read data for that snapshot during the transaction, potentially could cause memory pressure when the transaction is a long running one.

### ReadCommitted isolation level for Read-Only transaction

It is relative easy to support RC isolation level for Read-only transaction. The idea is that the read request comes to the partition with the flag for such isolation level, and the partition provide whatever the latest committed version of the data the request want. This is a non-intrusive read, no need to update ReadCache. When such read operation encounters a write-intent, there is no need to "push" the transaction as we do not want such read to abort possible on-going write-intent owning transaction. But we still have three different apporaches to handle the situation. 

1. "No-Check" -  Do not check if the write-intent owning transaction is commited or not from TRH. Ignore the write-intent as if it didn't exist and just read the last version before the write-intent. The benefit of this is that this is fastes approach and incure no extra network traffic in the three apporaches. The down side of this approach is that this is not traditionally RDMS community understanding of ReadCommitted, as some of write-intent may belong to transaction already committed (and just not yet finalized in K2-3SI), so such read may miss some recent committed value. The degree of such missing is implementation specific, it depends on how fast our system does finalization proecess in K2-3SI. Even worse, if the read transaction is after a write transaction of same client on the same data, and our system hasn't finalize the commited write transaction, it will show up as unable to read your own write anormaly. So it may be difficult for user to understand and use, even maybe in some case, the user scenario may doesn't care about such anormaly. This approach is not recommended. 
2. "Minimal-Check" - Only check if the write-intent owner transaction is commited or not from TRH when the write transaction has a smaller timestamp than this read only transaction. If commited, give this new version value(and update the write-intent to new committed version). As any write transaction that starts after this read transaction can be safely ignored regardless at the moment the read really happens (after the read timestamp) if or not it is committed or not. Such ignoring will not conflict with the correctness of ReadCommitted definition. Of course, as it is ReadCommitted isolation level, this approaches doesn't have the unable to read your own write anormaly. This approach is recommended.
3. "Full-check" - Check all write-intent if they are committed or not. The bad side is that it triggers more network traffic and may increase the read transaction latency. The good side is that this approach is slightly more like traditional monolithic RDMS RC isolation level by giving the version that is committed when you read it instead of when you start the read transaction. (In comparison with "Minimal-check", through both approach are indeed ReadCommitted) Between this approach and "Minimal-Check", "Minimal-Check" is recommended. 

Note that for Read-Only transaction, even internally in Chogori, it starts with a timestamp for the purpose to do "Minimal-Check", it doesn't read a snapshot of the system, it means there is no timestamp need to exposed to client. As this read transaction may read result from a write transaction that started later than the read transaction but already committed when the read operation (of the read transaction) read the data changed. This is like a read transaction could see future change if we give the read transaciton the starting timestamp and order all transactions based on their starting timestamp(as done in K2-3SI). Since this is a read-only transaction, there is no such transaction timestamp exposed, so it is ok. This point need to be checked again when we discuss about RC Read-write mixed transaction in the following section. 

### ReadCommitted isolation level for read-write mixed transaction

Supporting read-write mixed transaction in RC isolation level is tricker. As it still need to go through the conflict detection and "push" process when read-write or write-write conflict is detected, it is recommended to <b>not</b> implement ReadCommitted isolation level for read-write mixed transaction. Instead just directly to use typical K2-3SI Serializable Snapshot Isolation level transaction, as its cost is same and provide higher isolation level without anormaly, while equally important, easier for application user to reason about.

Following discussion is a brief description on how to implement it so that we record the detail thinking about it to proves the conclusion above. In order to have sufficient isolation for the other possible concurrent Serializable Snapshot Isolation transactions, for the write operation, we need to check the read-write and write-write conflict detection and push handling as in K2-3SI. For the read operations, we can do partially the same as in Read-Only transaction case, where we will have to update the read cache when needed. The reason is following: the read committed isolation requires to be able to see the data committed before current transaction starts, if we do not update read cache, there may be another write transaction, which starts earlier than our transaction, could come in change the data after we read the data but mark the changed version less than our version. The root cause of this is the discrepansy that in Chogori K2-3SI ordering visibility of committed transaction with transaction start time, while typical monolithic RDMS which provides RC level uses transaction commit time for order. Similarly, for the read operation in such mixed transaction, when read encounters a write-intent, we need to do "Minimal-Check", and if it encoutners a committed version, it should return the version that fits the transaction starting time stamp(e.g. if the mixed transaction is started at time 10, at time 15, read operation read a row with committed versions both 8 and 12, it should return version 8 instead of 12 to avoid read into future issue.) But there is chance such older version is no longer available it is out of data retention windows set in K2-3SI system and the mixed transaction has to abort (and maybe retry).

Final note, not able to provide an efficient ReadCommitted islation level for mixted transaction doesn't mean K2-3SI is less efficient than typical 2PC distributed transaction protocol (e.g. in Google spanner). Even RC is provided there, the commit process still need to be performed in 2 phases and write set need to be verified, further more true time uncertainty windows need to be waited out after commit. Such latency cost is higher than regular K2-3SI transaction already as discussed in TXN.md.
